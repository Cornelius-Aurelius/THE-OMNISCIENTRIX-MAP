<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">

<title>Omniscientrix Universe Map vΩ.∞ MASTER — Hybrid Quantum AI Engine</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #000;
  font-family: Arial, sans-serif;
  color: #9ee7ff;
  user-select: none;
}

/* MOBILE MENU BUTTON */
#toggleBtn {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #003355dd;
  color: #9ee7ff;
  padding: 10px 14px;
  border-radius: 10px;
  border: 1px solid #00aaff88;
  cursor: pointer;
  font-size: 16px;
  display: none;
  z-index: 999;
}

/* CONTROL PANEL */
#uiPanel {
  position: fixed;
  top: 20px;
  right: 20px;
  width: 320px;
  padding: 18px;
  background: rgba(0,18,35,0.65);
  border: 1px solid #00caff77;
  border-radius: 16px;
  backdrop-filter: blur(10px);
  color: #b9f2ff;
  box-shadow: 0 0 12px #0099ff55;
  z-index: 998;
  transition: transform .35s ease;
}

#uiPanel h1 {
  margin: 0 0 14px;
  font-size: 22px;
  color: #7eeaff;
  text-shadow: 0 0 10px #0099ccaa;
}

#uiPanel label {
  font-size: 14px;
  margin-bottom: 6px;
  display: block;
}

#uiPanel select,
#uiPanel input[type=range],
#uiPanel input[type=text],
#uiPanel button,
#uiPanel input[type=checkbox] {
  width: 100%;
  margin-bottom: 10px;
  padding: 6px;
  background: #001c2a;
  border: 1px solid #00caff55;
  border-radius: 8px;
  color: #aeefff;
}

#uiPanel button {
  cursor: pointer;
  background: #002a44;
  border: 1px solid #0099cc;
}
#uiPanel button:hover {
  background: #004466;
}

canvas {
  display: block;
}

/* SYSTEM PANEL */
#systemPanel {
  position: fixed;
  top: 20px;
  left: 20px;
  width: 280px;
  padding: 16px;
  background: rgba(0,15,30,0.8);
  border: 1px solid #0099cc88;
  border-radius: 12px;
  backdrop-filter: blur(10px);
  box-shadow: 0 0 14px #00aaff44;
  z-index: 900;
  display: none;
  color: #9ee7ff;
}
#systemPanel h2 {
  margin-top: 0;
  font-size: 20px;
  color: #88e1ff;
}
#systemPanel .closeBtn {
  text-align: right;
  cursor: pointer;
  color: #66d0ff;
}

/* MINI-MAP */
#miniMap {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 180px;
  height: 180px;
  background: rgba(0,20,40,0.7);
  border: 1px solid #0099cc88;
  border-radius: 12px;
  box-shadow: 0 0 10px #00aaff33;
  backdrop-filter: blur(8px);
  z-index: 900;
}
#miniMap canvas {
  width: 100%;
  height: 100%;
  border-radius: 12px;
}

/* FOOTER */
#footer {
  position: fixed;
  bottom: 12px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 12px;
  color: #00baff;
  text-align: center;
}
#footer a {
  color: #66e0ff;
  text-decoration: none;
  text-shadow: 0 0 4px #0088cc;
}

/* MOBILE */
@media(max-width: 920px){
  #toggleBtn { display: block; }
  #uiPanel { transform: translateX(140%); }
  #uiPanel.open { transform: translateX(0); }
}
</style>
</head>

<body>

<div id="toggleBtn">Ω MENU</div>

<div id="uiPanel">
  <h1>Ω.∞ CONTROL PANEL</h1>

  <label>Field Mode</label>
  <select id="modeSel">
    <option value="blend">Ω-Quantum Blend</option>
    <option value="life">Ω-Life Resonance</option>
    <option value="curv">Ω-Curvature Field</option>
    <option value="aware">Awareness Tensor</option>
    <option value="flux">Information Flux</option>
    <option value="ghz">Quantum GHZ</option>
    <option value="horizon">Entropy Horizon</option>
    <option value="collapse">Collapse–Diffusion</option>
    <option value="star">Real Star Spectra</option>
    <option value="ai">Ω-AI Life Prediction</option>
    <option value="dyson">Ω-Dyson Technosignature</option>
    <option value="constel">Ω-Constellation Mode</option>
  </select>

  <label>Ω-Intensity</label>
  <input type="range" id="omegaInt" min="0" max="1" step="0.01" value="0.55">

  <label>Timewarp</label>
  <input type="range" id="timeWarp" min="0.1" max="5" step="0.1" value="1">

  <label>AstroCamera</label>
  <input type="checkbox" id="astroCam">

  <label>Draw Constellations</label>
  <input type="checkbox" id="drawConst" checked>

  <label>Find Star (temp/class)</label>
  <input type="text" id="starSearch" placeholder="e.g. 6000K or G">

  <button id="starSearchBtn">Search</button>
  <button id="saveConst">Save Constellation</button>
  <button id="loadConst">Load Saved</button>
  <button id="clearConst">Clear</button>
</div>

<div id="systemPanel">
  <div class="closeBtn">✕ Close</div>
  <h2 id="sysName"></h2>
  <div id="sysData"></div>
</div>

<div id="miniMap">
  <canvas id="miniMapCanvas"></canvas>
</div>

<canvas id="universe"></canvas>

<div id="footer">
© 2025 Cornelius Aurelius · 
<a href="https://corneliusaurelius.com/">Site</a> ·
<a href="https://medium.com/@138licensing">Medium</a> ·
<a href="mailto:138licensing@gmail.com">Email</a> ·
<a href="https://zenodo.org/records/17362534">Zenodo</a> ·
<a href="https://www.instagram.com/cornelius_aurelius_/">Instagram</a> ·
<a href="https://www.linkedin.com/in/cornelius-aurelius-404805325/recent-activity/all/">LinkedIn</a>
</div>

<script>
/* ASTROCAM BUFFER FIX */
let astroBuffer = document.createElement("canvas");
astroBuffer.width = innerWidth;
astroBuffer.height = innerHeight;
let astroCtx = astroBuffer.getContext("2d", { alpha: false });

window.addEventListener("resize", () => {
  astroBuffer.width = innerWidth;
  astroBuffer.height = innerHeight;
});

/* CANVAS */
const c = document.getElementById("universe");
let ctx = c.getContext("2d", { alpha: false });

let W, H;
function resize(){
  W = c.width = innerWidth;
  H = c.height = innerHeight;
}
resize();
addEventListener("resize", resize);

/* CAMERA */
let cam = { x:0, y:0, z:1600, drag:false, lx:0, ly:0 };

c.addEventListener("mousedown", e=>{
  cam.drag = true;
  cam.lx = e.clientX;
  cam.ly = e.clientY;
});
addEventListener("mouseup", ()=> cam.drag=false);

c.addEventListener("mousemove", e=>{
  if (cam.drag){
    cam.x -= (e.clientX - cam.lx) * 1.15;
    cam.y -= (e.clientY - cam.ly) * 1.15;
    cam.lx = e.clientX;
    cam.ly = e.clientY;
  }
});

/* ZOOM */
c.addEventListener("wheel", e=>{
  cam.z += e.deltaY*0.5;
  cam.z = Math.max(200, Math.min(6000, cam.z));
});

/* TOUCH */
let touchId=null;
c.addEventListener("touchstart", e=>{
  if (e.touches.length===1){
    touchId = e.touches[0].identifier;
    cam.drag = true;
    cam.lx = e.touches[0].clientX;
    cam.ly = e.touches[0].clientY;
  }
});
c.addEventListener("touchmove", e=>{
  for (const t of e.touches){
    if (t.identifier===touchId && cam.drag){
      cam.x -= (t.clientX - cam.lx) * 1.15;
      cam.y -= (t.clientY - cam.ly) * 1.15;
      cam.lx = t.clientX;
      cam.ly = t.clientY;
    }
  }
});
c.addEventListener("touchend", ()=>{ cam.drag=false; touchId=null; });

/* ROTATION */
let rotation = 0;
c.addEventListener("mousemove", e=>{
  if (cam.drag && e.shiftKey){
    rotation += (e.clientX - cam.lx)*0.0025;
    cam.lx = e.clientX;
  }
});

/* SPEED KERNEL */
let lastTime = performance.now();
let smoothing = 0.92;
window.OmegaSpeed = {
  dt: 0.016,
  speedFactor: 1,
  update(){
    const now = performance.now();
    const elapsed = (now-lastTime)/1000;
    lastTime = now;
    this.dt = this.dt*smoothing + elapsed*(1-smoothing);
    this.speedFactor =
      this.dt > 0.030 ? 0.70 :
      this.dt > 0.022 ? 0.87 : 1.00;
  }
};

/* MOTION */
window.OmegaMotion = {
  vx:0, vy:0, damping:0.90,
  apply(cam){
    cam.x -= this.vx * OmegaSpeed.speedFactor;
    cam.y -= this.vy * OmegaSpeed.speedFactor;
    this.vx *= this.damping;
    this.vy *= this.damping;
  }
};

/* ADVANCED GALAXY STRUCTURE */
function spiralHarmonics(x,y){
  const r = Math.sqrt(x*x+y*y);
  const t = Math.atan2(y,x);
  const base = Math.cos(4*(t - Math.log(r+1)*0.23));
  const h2 = Math.cos(6*(t - Math.log(r+1)*0.18));
  const h3 = Math.cos(3*(t - Math.log(r+1)*0.27));
  return Math.max(0, base*0.65 + h2*0.25 + h3*0.10);
}

function dustLane(x,y){
  const yAbs = Math.abs(y);
  return Math.exp(-(yAbs*yAbs)/8000000);
}

function bulgeWeight(x,y){
  const r = Math.sqrt(x*x + y*y);
  return Math.exp(-(r*r)/50000000);
}

function diskDensity(z){
  return Math.exp(-(z*z)/40000000)*0.85 +
         Math.exp(-(z*z)/140000000)*0.15;
}

/* STAR GENERATION */
let stars = [];
const STAR_COUNT = 42000;

for (let i=0;i<STAR_COUNT;i++){
  let r = (Math.random()**0.52)*24000;
  let t = Math.random()*Math.PI*2;

  let x = r*Math.cos(t);
  let y = r*Math.sin(t);

  let armBoost = spiralHarmonics(x,y);
  if (Math.random() < armBoost*0.75){
    x *= 1+(Math.random()-0.5)*0.10;
    y *= 1+(Math.random()-0.5)*0.10;
  }

  let z = 200 + Math.random()*9000;
  if (Math.random()<0.15) z *= 1+(Math.random()*0.5);

  stars.push({
    x,y,z,
    temp: 2500+Math.random()*20000,
    aware: Math.random(),
    flux: Math.random(),
    alphaMod: 1 - dustLane(x,y)*0.25,
    bulge: bulgeWeight(x,y)
  });
}

/* DEEP SPACE STARS */
window.deepStars = [];
const DEEP_COUNT = 30000;
for (let i=0;i<DEEP_COUNT;i++){
  deepStars.push({
    x:(Math.random()-0.5)*150000,
    y:(Math.random()-0.5)*150000,
    z:9000+Math.random()*30000,
    a:0.05+Math.random()*0.10
  });
}

function drawDeepStars(){
  for (const s of deepStars){
    let d = s.z / cam.z;
    if (d>12) continue;
    let X = W/2 + (s.x-cam.x)*0.7/d;
    let Y = H/2 + (s.y-cam.y)*0.7/d;
    ctx.fillStyle = `rgba(255,255,255,${s.a*0.2})`;
    ctx.fillRect(X,Y,1,1);
  }
}

function drawGalaxyDensity(){
  let g = ctx.createRadialGradient(W/2,H/2,0,W/2,H/2,W*0.8);
  g.addColorStop(0, "rgba(255,255,255,0.02)");
  g.addColorStop(0.4,"rgba(255,255,255,0.01)");
  g.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);
}

function drawBulge(){
  let g = ctx.createRadialGradient(W/2,H/2,30,W/2,H/2,400);
  g.addColorStop(0,"rgba(255,230,180,0.22)");
  g.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);
}

function spectralColor(T){
  T = Math.max(1500,Math.min(40000,T))/1000;
  let r,g,b;
  if (T<=6.6) r=255;
  else r=329.7*Math.pow(T-6.6,-0.1332), r=Math.min(255,Math.max(0,r));
  if (T<=6.6){
    g=99.47*Math.log(T)-161.12;
  } else {
    g=288.12*Math.pow(T-6.6,-0.0755);
  }
  g=Math.min(255,Math.max(0,g));

  if (T>=6.6) b=255;
  else if (T<=1) b=0;
  else {
    b=138.52*Math.log(T-1)-305.04;
    b=Math.min(255,Math.max(0,b));
  }

  return `rgba(${r},${g},${b},0.95)`;
}

/* GHZ */
function ghzIntensity(x,y){
  const r = Math.sqrt(x*x + y*y);
  return Math.exp(-Math.abs(r-12000)/5500);
}

/* Projection */
function projectPoint(x,y,z){
  let cx = x * Math.cos(rotation) - y * Math.sin(rotation);
  let cy = x * Math.sin(rotation) + y * Math.cos(rotation);

  let d = z / cam.z;
  let X = W/2 + (cx - cam.x) * 1.05 / d;
  let Y = H/2 + (cy - cam.y) * 1.05 / d;

  return { X, Y, d };
}

function drawTrail(s, X, Y, d){
  const len = (1.6 / d) * OmegaSpeed.speedFactor * (0.5 + timewarp*0.5);
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(X, Y);
  ctx.lineTo(X - len, Y - len*0.3);
  ctx.stroke();
}

/* NEBULA */
let nebulaClouds = [];
const NEBULA_COUNT = 14;

for (let i=0; i<NEBULA_COUNT; i++){
  nebulaClouds.push({
    x:(Math.random()-0.5)*30000,
    y:(Math.random()-0.5)*30000,
    size:4000 + Math.random()*6000,
    color:{
      r:60 + Math.random()*140,
      g:40 + Math.random()*90,
      b:160 + Math.random()*60,
      a:0.05 + Math.random()*0.10
    }
  });
}

function nebulaPulseAlpha(a){
  return a * (0.65 + 0.35*Math.sin(performance.now()/1400 * timewarp));
}

function drawNebulaClouds(){
  for (const n of nebulaClouds){
    let g = ctx.createRadialGradient(
      W/2 + (n.x - cam.x)*0.002,
      H/2 + (n.y - cam.y)*0.002,
      n.size*0.05,
      W/2 + (n.x - cam.x)*0.002,
      H/2 + (n.y - cam.y)*0.002,
      n.size
    );

    const c = n.color;
    g.addColorStop(0, `rgba(${c.r},${c.g},${c.b},${nebulaPulseAlpha(c.a)})`);
    g.addColorStop(1, `rgba(${c.r},${c.g},${c.b},0)`);

    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }
}

/* DUST */
let dustParticles = [];
for (let i=0;i<8000;i++){
  dustParticles.push({
    x:(Math.random()-0.5)*50000,
    y:(Math.random()-0.5)*50000,
    z:100 + Math.random()*10000,
    a:0.02 + Math.random()*0.05
  });
}

function drawDust(){
  for (const d of dustParticles){
    let DD = d.z / cam.z;
    if (DD>5) continue;
    let X = W/2 + (d.x-cam.x)*1.2/DD;
    let Y = H/2 + (d.y-cam.y)*1.2/DD;
    ctx.fillStyle = `rgba(255,255,255,${d.a})`;
    ctx.fillRect(X,Y,1,1);
  }
}

/* SUPERNOVAE */
let supernovae = [];
function spawnSupernova(s){
  supernovae.push({
    x:s.x, y:s.y, z:s.z,
    t:0,
    life:2000 + Math.random()*1500,
    brightness:1
  });
}

function updateSupernova(dt){
  for (const sn of supernovae){
    sn.t += dt*1000*timewarp;
    sn.brightness = Math.max(0,1 - sn.t/sn.life);
  }
}

function drawSupernovae(){
  for (const sn of supernovae){
    let P = projectPoint(sn.x, sn.y, sn.z);
    let s = 60 * sn.brightness * OmegaSpeed.speedFactor * (timewarp*0.3+1);
    let g = ctx.createRadialGradient(P.X,P.Y,0,P.X,P.Y,s);
    g.addColorStop(0, `rgba(255,220,180,${sn.brightness})`);
    g.addColorStop(0.3,`rgba(255,100,60,${sn.brightness*0.6})`);
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }
}

/* PLANETS */
for (const s of stars){
  const hasPlanets =
    Math.random() < 0.35 ||
    s.temp < 6500 ||
    ghzIntensity(s.x, s.y) > 0.45;

  if (!hasPlanets){
    s.planets = [];
    continue;
  }

  const count = Math.floor(Math.random()*10) + 1;
  s.planets = [];

  for (let i=0; i<count; i++){
    const dist = 40 + i*(60 + Math.random()*50);
    const angle = Math.random()*Math.PI*2;
    const pTemp = s.temp / (1 + dist/300);
    const types = ["terrestrial","ice","lava","ocean","gas giant"];
    const type = types[Math.floor(Math.random()*types.length)];

    s.planets.push({
      angle,
      dist,
      radius: 0.8 + Math.random()*4,
      type,
      temp: pTemp,
      flux: 1 / (1 + dist/400),
      o2: Math.random()*0.25,
      ch4: Math.random()*0.04,
      co2: Math.random()*0.12,
      planethost: s
    });
  }
}

function updateStarSystemOrbits(dt){
  for (const s of stars){
    for (const p of s.planets){
      const spd = 0.00025 + Math.random()*0.0004;
      p.angle += spd * dt * timewarp;
    }
  }
}

function pNoise(x, y){
  return (Math.sin(x*12.98 + y*78.2)*43758.5) % 1;
}

function sampleSurfaceColor(type, x, y, temp){
  let v1 = pNoise(x, y);
  let v2 = pNoise(x*0.6, y*0.6);
  let v = v1*0.6 + v2*0.4;

  switch(type){
    case "ice":
      return `rgba(${200+v*40},${220+v*30},255,1)`;
    case "lava":
      return `rgba(${180+v*70},${40+v*30},${30+v*20},1)`;
    case "ocean":
      return `rgba(${40+v*30},${80+v*40},${180+v*40},1)`;
    case "gas giant":
      return `rgba(${180+v*60},${140+v*50},${220+v*50},1)`;
    default:
      return `rgba(${90+v*80},${120+v*70},${60+v*40},1)`;
  }
}

function drawPlanetSurface(px, py, size, p, spin){
  let steps = Math.floor(size*2);
  for (let i=0;i<steps;i++){
    for (let j=0;j<steps;j++){
      let dx = i-size;
      let dy = j-size;
      if (dx*dx + dy*dy > size*size) continue;

      let sx = dx/size + spin*0.3;
      let sy = dy/size;
      ctx.fillStyle = sampleSurfaceColor(p.type, sx, sy, p.temp);
      ctx.fillRect(px+dx, py+dy, 1,1);
    }
  }
}

function atmosphericGlow(size, px, py, p){
  const col = {
    ice:"rgba(180,220,255,0.35)",
    lava:"rgba(255,120,40,0.25)",
    ocean:"rgba(120,180,255,0.3)",
    terrestrial:"rgba(180,220,255,0.18)",
    "gas giant":"rgba(200,160,255,0.25)"
  }[p.type] || "rgba(180,220,255,0.18)";

  ctx.beginPath();
  ctx.arc(px, py, size*1.15, 0, Math.PI*2);
  ctx.fillStyle = col;
  ctx.fill();
}

function cloudNoise(x,y,t){
  return (Math.sin(x*3.1+t*0.6)+Math.cos(y*2.7-t*0.4))*0.5;
}

function drawAtmosphere(px,py,size,p,t){
  atmosphericGlow(size,px,py,p);
  let steps = Math.floor(size*2);
  for (let i=0;i<steps;i++){
    for (let j=0;j<steps;j++){
      let dx = i-size;
      let dy = j-size;
      if (dx*dx+dy*dy>size*size) continue;

      let sx = dx/size;
      let sy = dy/size;
      let c = cloudNoise(sx,sy,t+p.angle*2);
      if (c>0.3){
        ctx.fillStyle = "rgba(255,255,255,0.12)";
        ctx.fillRect(px+dx,py+dy,1,1);
      }
    }
  }
}

function lightDirection(star, pos){
  const dx = star.x-pos.x;
  const dy = star.y-pos.y;
  const m = Math.sqrt(dx*dx+dy*dy)+0.0001;
  return {lx:dx/m, ly:dy/m};
}

function drawLighting(px,py,size,p,s){
  const light = lightDirection(s,{x:px,y:py});
  let steps = Math.floor(size*2);

  for (let i=0;i<steps;i++){
    for (let j=0;j<steps;j++){
      let dx=i-size, dy=j-size;
      if (dx*dx+dy*dy>size*size) continue;
      let sx=dx/size, sy=dy/size;
      let L = sx*light.lx + sy*light.ly;
      if (L<0){
        let n = Math.min(1, -L*0.9);
        ctx.fillStyle = `rgba(0,0,0,${n})`;
        ctx.fillRect(px+dx,py+dy,1,1);
      }
    }
  }
}

function drawRing(px,py,size,p,light){
  if (p.type!=="gas giant") return;
  ctx.strokeStyle="rgba(200,200,255,0.3)";
  ctx.lineWidth=1.1;
  ctx.beginPath();
  ctx.ellipse(px,py,size*1.8,size*0.45,Math.atan2(light.ly,light.lx),0,Math.PI*2);
  ctx.stroke();
}

function drawRingShadow(px,py,size,p,s){
  if (p.type!=="gas giant") return;
  const light = lightDirection(s,{x:px,y:py});
  ctx.strokeStyle="rgba(0,0,0,0.22)";
  ctx.lineWidth=1.2;

  ctx.beginPath();
  ctx.ellipse(
    px-light.lx*size*0.5,
    py-light.ly*size*0.5,
    size*1.8,size*0.45,
    Math.atan2(light.ly,light.lx),
    0,Math.PI*2
  );
  ctx.stroke();
}

let weatherTime = 0;
function updateWeather(dt){ weatherTime += dt*timewarp; }

function cycloneField(x,y,t){
  return Math.sin((x*3+t*0.3))*Math.cos((y*3-t*0.3));
}

function lightningFlash(p){
  let chance = 0.0003 + p.temp/200000;
  return Math.random()<chance;
}

function drawWeather(px,py,size,p){
  let steps=Math.floor(size*2);
  for (let i=0;i<steps;i++){
    for (let j=0;j<steps;j++){
      let dx=i-size, dy=j-size;
      if (dx*dx+dy*dy>size*size) continue;

      let sx=dx/size, sy=dy/size;
      let storm=cycloneField(sx,sy,weatherTime+p.angle*3);
      if (storm>0.38){
        ctx.fillStyle="rgba(255,255,255,0.14)";
        ctx.fillRect(px+dx,py+dy,1,1);
      }
      if (lightningFlash(p)){
        ctx.fillStyle="rgba(255,255,200,0.25)";
        ctx.fillRect(px+dx,py+dy,1,1);
      }
    }
  }
}

function civIntensity(p){
  let life = OmegaAI.predict ? OmegaAI.predict(p.planethost) : 0;
  let tech = p.flux*0.4 + p.temp/10000*0.2;
  let collapse = OmegaCollapse ? OmegaCollapse.evolve(p.planethost) : 0;
  let v = life*0.5 + tech*0.3 + (1-collapse)*0.2;
  return Math.max(0,Math.min(1,v));
}

function drawCityLights(px,py,size,p,s){
  let civ=civIntensity(p);
  if (civ<0.15) return;
  const light=lightDirection(s,{x:px,y:py});
  let steps=Math.floor(size*2);

  for (let i=0;i<steps;i++){
    for (let j=0;j<steps;j++){
      let dx=i-size, dy=j-size;
      if (dx*dx+dy*dy>size*size) continue;

      let sx=dx/size, sy=dy/size;
      let L=sx*light.lx + sy*light.ly;
      if (L>-0.15) continue;

      let city = Math.sin(sx*45+sy*52)+Math.cos(sx*55-sy*40);
      if (city>0.4){
        ctx.fillStyle=`rgba(255,220,120,${civ*0.35})`;
        ctx.fillRect(px+dx,py+dy,1,1);
      }
    }
  }
}

function drawStarSystemPlanets(){
  for (const s of stars){
    for (const p of s.planets){

      let px = s.x + Math.cos(p.angle)*p.dist;
      let py = s.y + Math.sin(p.angle)*p.dist;
      let pz = s.z;

      let Pp = projectPoint(px,py,pz);
      let size = Math.max(1.4, p.radius/(p.dist*0.03 + 0.7));
      let spin = p.angle;

      drawPlanetSurface(Pp.X,Pp.Y,size,p,spin);
      drawAtmosphere(Pp.X,Pp.Y,size,p,performance.now()/800);
      drawLighting(Pp.X,Pp.Y,size,p,s);

      const light = lightDirection(s,{x:Pp.X,y:Pp.Y});
      drawRingShadow(Pp.X,Pp.Y,size,p,s);
      drawRing(Pp.X,Pp.Y,size,p,light);

      drawWeather(Pp.X,Pp.Y,size,p);
      drawCityLights(Pp.X,Pp.Y,size,p,s);
    }
  }
}

/* AI MODELS */
window.OmegaAI = {
  predict(s){
    let ghz = ghzIntensity(s.x, s.y);
    let flux = s.flux;
    let aware = s.aware;
    let tempScore = (s.temp > 2400 && s.temp < 8000) ? 0.6 : 0.2;
    let score = ghz*0.45 + flux*0.25 + aware*0.2 + tempScore*0.1;
    return Math.max(0, Math.min(1, score));
  }
};

window.OmegaDyson = {
  score(s){
    let dim = Math.abs(Math.sin(s.x/5000)*Math.cos(s.y/7000));
    let ir = (s.temp < 5200 ? 0.4 : 0.1) + Math.sin(s.temp/1500)*0.25;
    let st = 1 - Math.abs((s.x % 2000) - 1000)/1000;
    let v = dim*0.35 + ir*0.45 + st*0.20;
    return Math.max(0, Math.min(1, v));
  },
  color(v){
    const r = Math.floor(40 + v*200);
    const g = Math.floor(10 + v*40);
    const b = Math.floor(255 - v*200);
    return `rgba(${r},${g},${b},0.95)`;
  }
};

window.OmegaCollapse = {
  evolve(s){ return Math.sin((s.x+s.y)/5000)*0.5 + 0.5; }
};

window.OmegaAwareness = {
  A(s){ return Math.abs(Math.sin(s.aware*3.14))*s.aware; }
};

window.OmegaFlux = {
  F(s){ return s.flux; }
};

window.OmegaHorizon = {
  H(s){
    let r = Math.sqrt(s.x*s.x + s.y*s.y);
    return Math.exp(-r/20000);
  }
};

/* CONSTELLATIONS */
window.constellations = [];
let drawing = false;
let lastStar = null;

function nearestStar(mx, my){
  let best=null, bd=999999;
  for (const s of stars){
    let P=projectPoint(s.x,s.y,s.z);
    let d=(mx-P.X)**2+(my-P.Y)**2;
    if (d<50 && d<bd){ best=s; bd=d; }
  }
  return best;
}

c.addEventListener("mousedown", e=>{
  if (!document.getElementById("drawConst").checked) return;
  let s=nearestStar(e.clientX,e.clientY);
  if (s){ drawing=true; lastStar=s; }
});

c.addEventListener("mouseup", e=>{
  if (drawing){
    let s=nearestStar(e.clientX,e.clientY);
    if (s && lastStar && s!==lastStar){
      constellations.push({a:lastStar,b:s});
    }
  }
  drawing=false;
  lastStar=null;
});

function drawConstellations(){
  ctx.strokeStyle="rgba(80,180,255,0.9)";
  ctx.lineWidth=1.4;
  for (const L of constellations){
    let A=projectPoint(L.a.x,L.a.y,L.a.z);
    let B=projectPoint(L.b.x,L.b.y,L.b.z);
    ctx.beginPath();
    ctx.moveTo(A.X,A.Y);
    ctx.lineTo(B.X,B.Y);
    ctx.stroke();
  }
}

window.aiConstellations = [];
function detectShapes(){
  aiConstellations.length=0;
  for (let i=0;i<constellations.length;i++){
    for (let j=i+1;j<constellations.length;j++){
      const A=constellations[i], B=constellations[j];
      if (A.a===B.a || A.b===B.b || A.a===B.b || A.b===B.a){
        let ax=(A.a.x+A.b.x+B.a.x+B.b.x)/4;
        let ay=(A.a.y+A.b.y+B.a.y+B.b.y)/4;
        let P=projectPoint(ax,ay,2000);
        aiConstellations.push({X:P.X, Y:P.Y});
      }
    }
  }
}

function drawAIConstellations(){
  for (const p of aiConstellations){
    const pulse=0.5+0.5*Math.sin(performance.now()/300);
    ctx.beginPath();
    ctx.arc(p.X,p.Y,6+pulse*3,0,Math.PI*2);
    ctx.strokeStyle=`rgba(0,200,255,${0.5+pulse*0.4})`;
    ctx.lineWidth=1.5;
    ctx.stroke();
  }
}

/* ROUTES + TRAFFIC */
window.routeNodes = [];
function generateRouteNodes(){
  routeNodes.length=0;
  for (const s of stars){
    if (OmegaDyson.score(s)>0.65 || OmegaAI.predict(s)>0.65)
      routeNodes.push(s);
  }
  if (routeNodes.length<12){
    for (let i=0;i<stars.length;i+=3500)
      routeNodes.push(stars[i]);
  }
}
generateRouteNodes();

window.routes = [];
function generateRoutes(){
  routes.length=0;
  for (let i=0;i<routeNodes.length;i++){
    for (let j=i+1;j<routeNodes.length;j++){
      const A=routeNodes[i], B=routeNodes[j];
      const dx=A.x-B.x, dy=A.y-B.y;
      const dist=Math.sqrt(dx*dx+dy*dy);
      if (dist<15000 && dist>2000){
        routes.push({A,B,dist});
      }
    }
  }
}
generateRoutes();

function drawRoutes(){
  ctx.lineWidth = 1.3;
  for (const R of routes){
    let A=projectPoint(R.A.x,R.A.y,R.A.z);
    let B=projectPoint(R.B.x,R.B.y,R.B.z);
    let intensity = Math.min(1, 7000/R.dist);
    ctx.strokeStyle=`rgba(0,180,255,${0.5*intensity})`;
    ctx.beginPath();
    ctx.moveTo(A.X,A.Y);
    ctx.lineTo(B.X,B.Y);
    ctx.stroke();
  }
}

window.ftlTraffic=[];
function generateTraffic(){
  ftlTraffic.length=0;
  for (const R of routes){
    let c=3+Math.floor(Math.random()*4);
    for (let i=0;i<c;i++){
      ftlTraffic.push({
        R,
        t:Math.random(),
        speed:0.0005+Math.random()*0.0015
      });
    }
  }
}
generateTraffic();

function updateTraffic(dt){
  for (const p of ftlTraffic){
    p.t += p.speed * dt * timewarp;
    if (p.t>1){ p.t=0; p.speed=0.0005+Math.random()*0.0015; }
  }
}

function drawTraffic(){
  for (const p of ftlTraffic){
    const R=p.R;
    const x=R.A.x+(R.B.x-R.A.x)*p.t;
    const y=R.A.y+(R.B.y-R.A.y)*p.t;
    const z=R.A.z+(R.B.z-R.A.z)*p.t;
    let P = projectPoint(x,y,z);
    const glow = 0.6 + 0.4*Math.sin(performance.now()/150);
    ctx.beginPath();
    ctx.arc(P.X,P.Y,2.4,0,Math.PI*2);
    ctx.fillStyle=`rgba(0,200,255,${glow})`;
    ctx.fill();
  }
}

/* ANOMALIES */
function anomalyScore(s){
  return (
    Math.abs(OmegaCollapse.evolve(s))*0.4 +
    OmegaDyson.score(s)*0.4 +
    s.flux*0.2
  );
}

function drawBeacons(){
  for (const s of stars){
    let A = anomalyScore(s);
    if (A < 0.75) continue;

    let P = projectPoint(s.x,s.y,s.z);
    const pulse = 0.6 + 0.4*Math.sin(performance.now()/200);
    ctx.beginPath();
    ctx.arc(P.X,P.Y,4+pulse*3,0,Math.PI*2);
    ctx.strokeStyle=`rgba(255,80,120,${A*0.7})`;
    ctx.lineWidth=1.8;
    ctx.stroke();
  }
}

/* STAR PANEL */
const sysPanel=document.getElementById("systemPanel");
const sysName=document.getElementById("sysName");
const sysData=document.getElementById("sysData");

function spectralClass(temp){
  if (temp < 3700) return "M (Red Dwarf)";
  if (temp < 5200) return "K (Orange)";
  if (temp < 6000) return "G (Yellow)";
  if (temp < 7500) return "F (Yellow-White)";
  if (temp < 10000) return "A (White)";
  if (temp < 30000) return "B (Blue-White)";
  return "O (Blue)";
}

c.addEventListener("click", e=>{
  const mx = e.clientX, my = e.clientY;
  let found = null;
  let closest = 999999;

  for (const s of stars){
    let P = projectPoint(s.x,s.y,s.z);
    let d = (mx-P.X)**2 + (my-P.Y)**2;
    if (d < 20 && d < closest){
      closest = d;
      found = s;
    }
  }

  if (found) showSystemPanel(found);
});

function showSystemPanel(s){

  sysName.textContent = "Star System";

  let D = OmegaDyson.score(s);
  let A = OmegaAwareness.A(s);
  let C = OmegaCollapse.evolve(s);
  let F = s.flux;
  let GHZ = ghzIntensity(s.x,s.y);
  let life = OmegaAI.predict(s);
  let spec = spectralClass(s.temp);

  let planetHTML="";
  if (s.planets.length===0){
    planetHTML="<i>No detected planets</i>";
  } else {
    for (let i=0;i<s.planets.length;i++){
      let p=s.planets[i];
      planetHTML +=`
        <b>Planet ${i+1} (${p.type})</b><br>
        Radius: ${p.radius.toFixed(2)} Earths<br>
        Temp: ${p.temp.toFixed(1)} K<br>
        Flux: ${p.flux.toFixed(3)}<br>
        Atmos: O₂ ${(p.o2*100).toFixed(1)}%, CH₄ ${(p.ch4*100).toFixed(3)}%, CO₂ ${(p.co2*100).toFixed(1)}%<br>
        Orbit: ${p.dist.toFixed(1)} units<br><br>
      `;
    }
  }

  sysData.innerHTML=`
    <b>Temp:</b> ${s.temp.toFixed(0)} K<br>
    <b>Spectral:</b> ${spec}<br>
    <b>Dyson Probability:</b> ${(D*100).toFixed(1)}%<br>
    <b>Life Prediction:</b> ${(life*100).toFixed(1)}%<br>
    <b>Awareness:</b> ${A.toFixed(3)}<br>
    <b>Collapse:</b> ${C.toFixed(3)}<br>
    <b>Flux:</b> ${F.toFixed(3)}<br>
    <b>GHZ:</b> ${GHZ.toFixed(3)}<br><br>

    <h3>Planets:</h3>
    ${planetHTML}
  `;

  sysPanel.style.display="block";

  cam.x = s.x - W/8;
  cam.y = s.y - H/8;
}

document.querySelector("#systemPanel .closeBtn").onclick=()=>{
  sysPanel.style.display="none";
};

/* MINI MAP */
let mmCanvas=document.getElementById("miniMapCanvas");
let mmCtx=mmCanvas.getContext("2d");
mmCanvas.width=180;
mmCanvas.height=180;

function drawMiniMap(){
  mmCtx.fillStyle="#000";
  mmCtx.fillRect(0,0,180,180);

  mmCtx.strokeStyle="rgba(0,140,255,0.35)";
  mmCtx.lineWidth=1;
  for (const R of routes){
    let x1=(R.A.x/30000)*90+90;
    let y1=(R.A.y/30000)*90+90;
    let x2=(R.B.x/30000)*90+90;
    let y2=(R.B.y/30000)*90+90;
    mmCtx.beginPath();
    mmCtx.moveTo(x1,y1);
    mmCtx.lineTo(x2,y2);
    mmCtx.stroke();
  }

  mmCtx.fillStyle="#77ccff";
  for (const s of stars){
    let x=(s.x/30000)*90+90;
    let y=(s.y/30000)*90+90;
    mmCtx.fillRect(x,y,1,1);
  }

  mmCtx.strokeStyle="#ffcc00";
  mmCtx.lineWidth=2;
  let cx=(cam.x/30000)*90+90;
  let cy=(cam.y/30000)*90+90;
  mmCtx.beginPath();
  mmCtx.arc(cx,cy,6,0,Math.PI*2);
  mmCtx.stroke();
}

/* RENDER LOOP */
function render(){

  OmegaSpeed.update();
  updateWeather(OmegaSpeed.dt);
  updateTraffic(OmegaSpeed.dt);
  updateSupernova(OmegaSpeed.dt);
  updateStarSystemOrbits(OmegaSpeed.dt);

  let useAstro = document.getElementById("astroCam").checked;
  ctx = useAstro ? astroCtx : c.getContext("2d",{alpha:false});

  if (!useAstro){
    ctx.fillStyle="#000";
    ctx.fillRect(0,0,W,H);
  } else {
    astroCtx.fillStyle="rgba(0,0,0,0.08)";
    astroCtx.fillRect(0,0,W,H);
  }

  drawDeepStars();
  drawGalaxyDensity();
  drawBulge();
  drawNebulaClouds();
  drawDust();

  for (const s of stars){
    let P=projectPoint(s.x,s.y,s.z);
    if (P.d>4) continue;
    let C = spectralColor(s.temp);
    ctx.fillStyle=C;
    ctx.fillRect(P.X,P.Y,1.3,1.3);
    drawTrail(s,P.X,P.Y,P.d);
  }

  drawStarSystemPlanets();
  drawSupernovae();

  let mode=document.getElementById("modeSel").value;

  if (mode==="constel"){
    detectShapes();
    drawConstellations();
    drawAIConstellations();
  }

  if (mode==="dyson"){
    drawRoutes();
    drawTraffic();
    drawBeacons();
  }

  drawMiniMap();

  if (useAstro){
    c.getContext("2d").drawImage(astroBuffer,0,0);
  }

  requestAnimationFrame(render);
}

render();

/* MOBILE MENU */
document.getElementById("toggleBtn").onclick=()=>{
  document.getElementById("uiPanel").classList.toggle("open");
};
</script>

</body>
</html>
