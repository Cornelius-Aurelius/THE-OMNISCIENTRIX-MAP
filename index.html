<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">

<title>Omniscientrix Universe Map vΩ.∞ MASTER — Hybrid Quantum AI Engine</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
/* ============================================================
   OMNISCIENTRIX UNIVERSE MAP vΩ.∞ MASTER EDITION
   THE MOST ADVANCED VERSION EVER CREATED
   — Neon Blue Quantum Theme —
============================================================ */

html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #000;
  font-family: Arial, sans-serif;
  color: #9ee7ff;
  user-select: none;
}

/* ---------------- MOBILE MENU BUTTON ---------------- */
#toggleBtn {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #003355dd;
  color: #9ee7ff;
  padding: 10px 14px;
  border-radius: 10px;
  border: 1px solid #00aaff88;
  cursor: pointer;
  font-size: 16px;
  display: none;
  z-index: 999;
}

/* ---------------- CONTROL PANEL ---------------- */
#uiPanel {
  position: fixed;
  top: 20px;
  right: 20px;
  width: 320px;
  padding: 18px;
  background: rgba(0,18,35,0.65);
  border: 1px solid #00caff77;
  border-radius: 16px;
  backdrop-filter: blur(10px);
  color: #b9f2ff;
  box-shadow: 0 0 12px #0099ff55;
  z-index: 998;
  transition: transform .35s ease;
}

#uiPanel h1 {
  margin: 0 0 14px;
  font-size: 22px;
  color: #7eeaff;
  text-shadow: 0 0 10px #0099ccaa;
}

#uiPanel label {
  font-size: 14px;
  margin-bottom: 6px;
  display: block;
}

#uiPanel select,
#uiPanel input[type=range],
#uiPanel input[type=text],
#uiPanel button,
#uiPanel input[type=checkbox] {
  width: 100%;
  margin-bottom: 10px;
  padding: 6px;
  background: #001c2a;
  border: 1px solid #00caff55;
  border-radius: 8px;
  color: #aeefff;
}

#uiPanel button {
  cursor: pointer;
  background: #002a44;
  border: 1px solid #0099cc;
}
#uiPanel button:hover {
  background: #004466;
}

/* ---------------- CANVAS ---------------- */
canvas {
  display: block;
}

/* ---------------- SYSTEM PANEL ---------------- */
#systemPanel {
  position: fixed;
  top: 20px;
  left: 20px;
  width: 280px;
  padding: 16px;
  background: rgba(0,15,30,0.8);
  border: 1px solid #0099cc88;
  border-radius: 12px;
  backdrop-filter: blur(10px);
  box-shadow: 0 0 14px #00aaff44;
  z-index: 900;
  display: none;
  color: #9ee7ff;
}
#systemPanel h2 {
  margin-top: 0;
  font-size: 20px;
  color: #88e1ff;
}
#systemPanel .closeBtn {
  text-align: right;
  cursor: pointer;
  color: #66d0ff;
}

/* ---------------- MINI-MAP ---------------- */
#miniMap {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 180px;
  height: 180px;
  background: rgba(0,20,40,0.7);
  border: 1px solid #0099cc88;
  border-radius: 12px;
  box-shadow: 0 0 10px #00aaff33;
  backdrop-filter: blur(8px);
  z-index: 900;
}
#miniMap canvas {
  width: 100%;
  height: 100%;
  border-radius: 12px;
}

/* ---------------- FOOTER ---------------- */
#footer {
  position: fixed;
  bottom: 12px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 12px;
  color: #00baff;
  text-align: center;
}
#footer a {
  color: #66e0ff;
  text-decoration: none;
  text-shadow: 0 0 4px #0088cc;
}

/* ---------------- MOBILE ---------------- */
@media(max-width: 920px){
  #toggleBtn { display: block; }
  #uiPanel { transform: translateX(140%); }
  #uiPanel.open { transform: translateX(0); }
}
</style>
</head>

<body>

<!-- MOBILE MENU -->
<div id="toggleBtn">Ω MENU</div>

<!-- CONTROL PANEL -->
<div id="uiPanel">
  <h1>Ω.∞ CONTROL PANEL</h1>

  <label>Field Mode</label>
  <select id="modeSel">
    <option value="blend">Ω-Quantum Blend</option>
    <option value="life">Ω-Life Resonance</option>
    <option value="curv">Ω-Curvature Field</option>
    <option value="aware">Awareness Tensor</option>
    <option value="flux">Information Flux</option>
    <option value="ghz">Quantum GHZ</option>
    <option value="horizon">Entropy Horizon</option>
    <option value="collapse">Collapse–Diffusion</option>
    <option value="star">Real Star Spectra</option>
    <option value="ai">Ω-AI Life Prediction</option>
    <option value="dyson">Ω-Dyson Technosignature</option>
    <option value="constel">Ω-Constellation Mode</option>
  </select>

  <label>Ω-Intensity</label>
  <input type="range" id="omegaInt" min="0" max="1" step="0.01" value="0.55">

  <label>Timewarp</label>
  <input type="range" id="timeWarp" min="0.1" max="5" step="0.1" value="1">

  <label>AstroCamera</label>
  <input type="checkbox" id="astroCam">

  <label>Draw Constellations</label>
  <input type="checkbox" id="drawConst" checked>

  <label>Find Star (temp/class)</label>
  <input type="text" id="starSearch" placeholder="e.g. 6000K or G">

  <button id="starSearchBtn">Search</button>
  <button id="saveConst">Save Constellation</button>
  <button id="loadConst">Load Saved</button>
  <button id="clearConst">Clear</button>
</div>

<!-- SYSTEM PANEL -->
<div id="systemPanel">
  <div class="closeBtn">✕ Close</div>
  <h2 id="sysName"></h2>
  <div id="sysData"></div>
</div>

<!-- MINI MAP -->
<div id="miniMap">
  <canvas id="miniMapCanvas"></canvas>
</div>

<!-- MAIN CANVAS -->
<canvas id="universe"></canvas>

<!-- FOOTER -->
<div id="footer">
© 2025 Cornelius Aurelius · 
<a href="https://corneliusaurelius.com/">Site</a> ·
<a href="https://medium.com/@138licensing">Medium</a> ·
<a href="mailto:138licensing@gmail.com">Email</a> ·
<a href="https://zenodo.org/records/17362534">Zenodo</a> ·
<a href="https://www.instagram.com/cornelius_aurelius_/">Instagram</a> ·
<a href="https://www.linkedin.com/in/cornelius-aurelius-404805325/recent-activity/all/">LinkedIn</a>
</div>
<script>
/* ============================================================
   PART 2 — CANVAS ENGINE + CAMERA + FOUNDATIONAL GALAXY SYSTEM
   (Includes Ω-Speed, Ω-Motion, multi-harmonic spiral generation,
    deep-field background, dust lanes, bulge, and base stars)
============================================================ */

/* ---------------- CANVAS SETUP ---------------- */
const c = document.getElementById("universe");
let ctx = c.getContext("2d", { alpha: false });

let W, H;
function resize(){
  W = c.width = innerWidth;
  H = c.height = innerHeight;
}
resize();
addEventListener("resize", resize);

/* ---------------- CAMERA SYSTEM ---------------- */
let cam = { x:0, y:0, z:1600, drag:false, lx:0, ly:0 };

c.addEventListener("mousedown", e=>{
  cam.drag = true;
  cam.lx = e.clientX;
  cam.ly = e.clientY;
});
addEventListener("mouseup", ()=> cam.drag=false);

c.addEventListener("mousemove", e=>{
  if (cam.drag){
    cam.x -= (e.clientX - cam.lx) * 1.15;
    cam.y -= (e.clientY - cam.ly) * 1.15;
    cam.lx = e.clientX;
    cam.ly = e.clientY;
  }
});

/* Zoom */
c.addEventListener("wheel", e=>{
  cam.z += e.deltaY*0.5;
  cam.z = Math.max(200, Math.min(6000, cam.z));
});

/* Touch Controls */
let touchId=null;
c.addEventListener("touchstart", e=>{
  if (e.touches.length===1){
    touchId = e.touches[0].identifier;
    cam.drag = true;
    cam.lx = e.touches[0].clientX;
    cam.ly = e.touches[0].clientY;
  }
});
c.addEventListener("touchmove", e=>{
  for (const t of e.touches){
    if (t.identifier===touchId && cam.drag){
      cam.x -= (t.clientX - cam.lx) * 1.15;
      cam.y -= (t.clientY - cam.ly) * 1.15;
      cam.lx = t.clientX;
      cam.ly = t.clientY;
    }
  }
});
c.addEventListener("touchend", ()=>{ cam.drag=false; touchId=null; });

/* ---------------- CAMERA ROTATION (SHIFT + DRAG) ---------------- */
let rotation = 0;
c.addEventListener("mousemove", e=>{
  if (cam.drag && e.shiftKey){
    rotation += (e.clientX - cam.lx)*0.0025;
    cam.lx = e.clientX;
  }
});

/* ============================================================
   Ω-SPEED KERNEL — adaptive performance
============================================================ */
let lastTime = performance.now();
let smoothing = 0.92;
window.OmegaSpeed = {
  dt: 0.016,
  speedFactor: 1,
  update(){
    const now = performance.now();
    const elapsed = (now - lastTime)/1000;
    lastTime = now;
    this.dt = this.dt*smoothing + elapsed*(1-smoothing);
    this.speedFactor = this.dt > 0.030 ? 0.70 :
                       this.dt > 0.022 ? 0.87 : 1.00;
  }
};

/* ============================================================
   Ω-MOTION — camera inertia
============================================================ */
window.OmegaMotion = {
  vx:0, vy:0, damping:0.90,
  apply(cam){
    cam.x -= this.vx * OmegaSpeed.speedFactor;
    cam.y -= this.vy * OmegaSpeed.speedFactor;
    this.vx *= this.damping;
    this.vy *= this.damping;
  }
};

/* ============================================================
   ADVANCED GALAXY STRUCTURE (multi-harmonic spirals)
============================================================ */
function spiralHarmonics(x,y){
  const r = Math.sqrt(x*x+y*y);
  const t = Math.atan2(y,x);
  const base = Math.cos(4*(t - Math.log(r+1)*0.23));
  const h2 = Math.cos(6*(t - Math.log(r+1)*0.18));
  const h3 = Math.cos(3*(t - Math.log(r+1)*0.27));
  return Math.max(0, base*0.65 + h2*0.25 + h3*0.10);
}

/* Dust lane absorption */
function dustLane(x,y){
  const yAbs = Math.abs(y);
  return Math.exp(-(yAbs*yAbs)/8000000);
}

/* Central bulge */
function bulgeWeight(x,y){
  const r = Math.sqrt(x*x + y*y);
  return Math.exp(-(r*r)/50000000);
}

/* Disk thickness */
function diskDensity(z){
  return Math.exp(-(z*z)/40000000)*0.85 +
         Math.exp(-(z*z)/140000000)*0.15;
}

/* ============================================================
   STAR GENERATION (Ω.∞ PRIME)
============================================================ */
let stars = [];
const STAR_COUNT = 42000;

for (let i=0;i<STAR_COUNT;i++){
  let r = (Math.random()**0.52)*24000;
  let t = Math.random()*Math.PI*2;

  let x = r*Math.cos(t);
  let y = r*Math.sin(t);

  let armBoost = spiralHarmonics(x,y);
  if (Math.random() < armBoost*0.75){
    x *= 1+(Math.random()-0.5)*0.10;
    y *= 1+(Math.random()-0.5)*0.10;
  }

  let z = 200 + Math.random()*9000;
  if (Math.random()<0.15) z *= 1+(Math.random()*0.5);

  stars.push({
    x,y,z,
    temp: 2500+Math.random()*20000,
    aware: Math.random(),
    flux: Math.random(),
    alphaMod: 1 - dustLane(x,y)*0.25,
    bulge: bulgeWeight(x,y)
  });
}

/* ============================================================
   DEEP SPACE BACKGROUND STARS
============================================================ */
window.deepStars = [];
const DEEP_COUNT = 30000;

for (let i=0;i<DEEP_COUNT;i++){
  deepStars.push({
    x:(Math.random()-0.5)*150000,
    y:(Math.random()-0.5)*150000,
    z:9000+Math.random()*30000,
    a:0.05+Math.random()*0.10
  });
}

/* Deep star renderer */
function drawDeepStars(){
  for (const s of deepStars){
    let d = s.z / cam.z;
    if (d>12) continue;
    let X = W/2 + (s.x-cam.x)*0.7/d;
    let Y = H/2 + (s.y-cam.y)*0.7/d;
    ctx.fillStyle = `rgba(255,255,255,${s.a*0.2})`;
    ctx.fillRect(X,Y,1,1);
  }
}

/* Galaxy density gradient */
function drawGalaxyDensity(){
  let g = ctx.createRadialGradient(W/2,H/2,0,W/2,H/2,W*0.8);
  g.addColorStop(0, "rgba(255,255,255,0.02)");
  g.addColorStop(0.4,"rgba(255,255,255,0.01)");
  g.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);
}

/* Bulge bloom */
function drawBulge(){
  let g = ctx.createRadialGradient(W/2,H/2,30,W/2,H/2,400);
  g.addColorStop(0,"rgba(255,230,180,0.22)");
  g.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);
}

/* ============================================================
   BLACKBODY SPECTRAL SHADER (real star colour)
============================================================ */
function spectralColor(T){
  T = Math.max(1500,Math.min(40000,T))/1000;
  let r,g,b;

  if (T<=6.6) r=255;
  else r=329.7*Math.pow(T-6.6,-0.1332), r=Math.min(255,Math.max(0,r));

  if (T<=6.6){
    g=99.47*Math.log(T)-161.12;
  } else {
    g=288.12*Math.pow(T-6.6,-0.0755);
  }
  g=Math.min(255,Math.max(0,g));

  if (T>=6.6) b=255;
  else if (T<=1) b=0;
  else {
    b=138.52*Math.log(T-1)-305.04;
    b=Math.min(255,Math.max(0,b));
  }

  return `rgba(${r},${g},${b},0.95)`;
}
/* ============================================================
   PART 3 — GHZ • Nebula • Trails • Dust • Supernova • Projection
============================================================ */

/* ------------------------------------------------------------
   GHZ (Galactic Habitable Zone) Intensity
------------------------------------------------------------ */
function ghzIntensity(x,y){
  const r = Math.sqrt(x*x + y*y);
  let a = Math.exp(-Math.abs(r-12000)/5500);
  return a;
}

/* ------------------------------------------------------------
   PROJECT POINT INTO SCREEN SPACE (with rotation + parallax)
------------------------------------------------------------ */
function projectPoint(x,y,z){

  // rotate around galaxy center
  let cx = x * Math.cos(rotation) - y * Math.sin(rotation);
  let cy = x * Math.sin(rotation) + y * Math.cos(rotation);

  let d = z / cam.z;
  let X = W/2 + (cx - cam.x) * 1.05 / d;
  let Y = H/2 + (cy - cam.y) * 1.05 / d;

  return { X, Y, d };
}

/* ============================================================
   TRAILS (for moving stars, FTL, rotation, etc.)
============================================================ */
function drawTrail(s, X, Y, d){

  const len = (1.6 / d) * OmegaSpeed.speedFactor * (0.5 + timewarp*0.5);
  
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.lineWidth = 1;

  ctx.beginPath();
  ctx.moveTo(X, Y);
  ctx.lineTo(X - len, Y - len*0.3);
  ctx.stroke();
}

/* ============================================================
   NEBULA FRACTALS (Ω.∞ hybrid)
============================================================ */
let nebulaClouds = [];
const NEBULA_COUNT = 14;

for (let i=0; i<NEBULA_COUNT; i++){
  nebulaClouds.push({
    x:(Math.random()-0.5)*30000,
    y:(Math.random()-0.5)*30000,
    size:4000 + Math.random()*6000,
    color:{
      r:60 + Math.random()*140,
      g:40 + Math.random()*90,
      b:160 + Math.random()*60,
      a:0.05 + Math.random()*0.10
    }
  });
}

function nebulaPulseAlpha(a){
  return a * (0.65 + 0.35*Math.sin(performance.now()/1400 * timewarp));
}

function drawNebulaClouds(){
  for (const n of nebulaClouds){
    let g = ctx.createRadialGradient(
      W/2 + (n.x - cam.x)*0.002,
      H/2 + (n.y - cam.y)*0.002,
      n.size*0.05,
      W/2 + (n.x - cam.x)*0.002,
      H/2 + (n.y - cam.y)*0.002,
      n.size
    );

    const c = n.color;
    g.addColorStop(0, `rgba(${c.r},${c.g},${c.b},${nebulaPulseAlpha(c.a)})`);
    g.addColorStop(1, `rgba(${c.r},${c.g},${c.b},0)`);

    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }
}

/* ============================================================
   INTERSTELLAR MEDIUM DUST LAYER
============================================================ */
let dustParticles = [];
for (let i=0;i<8000;i++){
  dustParticles.push({
    x:(Math.random()-0.5)*50000,
    y:(Math.random()-0.5)*50000,
    z:100 + Math.random()*10000,
    a:0.02 + Math.random()*0.05
  });
}

function drawDust(){
  for (const d of dustParticles){
    let DD = d.z / cam.z;
    if (DD>5) continue;

    let X = W/2 + (d.x-cam.x)*1.2/DD;
    let Y = H/2 + (d.y-cam.y)*1.2/DD;

    ctx.fillStyle = `rgba(255,255,255,${d.a})`;
    ctx.fillRect(X,Y,1,1);
  }
}

/* ============================================================
   SUPERNOVA ENGINE (Ω-Quantum Collapse Model)
============================================================ */
let supernovae = [];

function spawnSupernova(s){
  supernovae.push({
    x:s.x, y:s.y, z:s.z,
    t:0,
    life:2000 + Math.random()*1500,
    brightness:1
  });
}

function updateSupernova(dt){
  for (const sn of supernovae){
    sn.t += dt*1000*timewarp;
    sn.brightness = Math.max(0,1 - sn.t/sn.life);
  }
}

function drawSupernovae(){
  for (const sn of supernovae){
    let P = projectPoint(sn.x, sn.y, sn.z);

    let s = 60 * sn.brightness * OmegaSpeed.speedFactor * (timewarp*0.3+1);

    let g = ctx.createRadialGradient(P.X,P.Y,0,P.X,P.Y,s);
    g.addColorStop(0, `rgba(255,220,180,${sn.brightness})`);
    g.addColorStop(0.3,`rgba(255,100,60,${sn.brightness*0.6})`);
    g.addColorStop(1, "rgba(0,0,0,0)");

    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }
}

/* ============================================================
   FTL ROUTE TRAFFIC + ANOMALY BEACONS
   (integrated previously, referenced here)
============================================================ */
// (Traffic, anomaly beacons already initialized in earlier blocks)
/* ============================================================
   PART 4 — PLANETARY SYSTEMS (FULL Ω.∞ ENGINE)
============================================================ */

/* ------------------------------------------------------------
   GENERATE PLANETARY SYSTEMS FOR EACH STAR
------------------------------------------------------------ */
for (const s of stars){

  // probability the star has planets
  const hasPlanets =
    Math.random() < 0.35 ||             // random chance
    s.temp < 6500 ||                     // cooler stars more likely
    ghzIntensity(s.x, s.y) > 0.45;       // inside GHZ

  if (!hasPlanets){
    s.planets = [];
    continue;
  }

  const count = Math.floor(Math.random()*10) + 1;

  s.planets = [];

  for (let i=0; i<count; i++){

    const dist = 40 + i*(60 + Math.random()*50);
    const angle = Math.random()*Math.PI*2;

    // planet temperature decreases with distance
    const pTemp = s.temp / (1 + dist/300);

    const types = ["terrestrial","ice","lava","ocean","gas giant"];
    const type = types[Math.floor(Math.random()*types.length)];

    s.planets.push({
      angle,
      dist,
      radius: 0.8 + Math.random()*4,
      type,
      temp: pTemp,
      flux: 1 / (1 + dist/400),
      o2: Math.random()*0.25,
      ch4: Math.random()*0.04,
      co2: Math.random()*0.12,
      planethost: s
    });
  }
}

/* ------------------------------------------------------------
   UPDATE PLANETARY ORBITS
------------------------------------------------------------ */
function updateStarSystemOrbits(dt){
  for (const s of stars){
    for (const p of s.planets){
      const spd = 0.00025 + Math.random()*0.0004;
      p.angle += spd * dt * timewarp;
    }
  }
}

/* ------------------------------------------------------------
   BASIC NOISE (fast pseudo-noise)
------------------------------------------------------------ */
function pNoise(x, y){
  return (Math.sin(x*12.98 + y*78.2)*43758.5) % 1;
}

/* ------------------------------------------------------------
   PLANET SURFACE COLOR TEXTURING
------------------------------------------------------------ */
function sampleSurfaceColor(type, x, y, temp){
  let v1 = pNoise(x, y);
  let v2 = pNoise(x*0.6, y*0.6);
  let v = v1*0.6 + v2*0.4;

  switch(type){
    case "ice":
      return `rgba(${200+v*40},${220+v*30},255,1)`;
    case "lava":
      return `rgba(${180+v*70},${40+v*30},${30+v*20},1)`;
    case "ocean":
      return `rgba(${40+v*30},${80+v*40},${180+v*40},1)`;
    case "gas giant":
      return `rgba(${180+v*60},${140+v*50},${220+v*50},1)`;
    default:
      return `rgba(${90+v*80},${120+v*70},${60+v*40},1)`;
  }
}

/* ------------------------------------------------------------
   DRAW PLANET SURFACE MAP
------------------------------------------------------------ */
function drawPlanetSurface(px, py, size, p, spin){
  let steps = Math.floor(size*2);
  for (let i=0;i<steps;i++){
    for (let j=0;j<steps;j++){

      let dx = i-size;
      let dy = j-size;
      if (dx*dx + dy*dy > size*size) continue;

      let sx = dx/size + spin*0.3;
      let sy = dy/size;

      ctx.fillStyle = sampleSurfaceColor(p.type, sx, sy, p.temp);
      ctx.fillRect(px+dx, py+dy, 1,1);
    }
  }
}

/* ------------------------------------------------------------
   ATMOSPHERIC GLOW
------------------------------------------------------------ */
function atmosphericGlow(size, px, py, p){
  const col = {
    ice:"rgba(180,220,255,0.35)",
    lava:"rgba(255,120,40,0.25)",
    ocean:"rgba(120,180,255,0.3)",
    terrestrial:"rgba(180,220,255,0.18)",
    "gas giant":"rgba(200,160,255,0.25)"
  }[p.type] || "rgba(180,220,255,0.18)";

  ctx.beginPath();
  ctx.arc(px, py, size*1.15, 0, Math.PI*2);
  ctx.fillStyle = col;
  ctx.fill();
}

/* ------------------------------------------------------------
   CLOUD LAYER
------------------------------------------------------------ */
function cloudNoise(x,y,t){
  return (Math.sin(x*3.1+t*0.6)+Math.cos(y*2.7-t*0.4))*0.5;
}
function drawAtmosphere(px,py,size,p,t){
  atmosphericGlow(size,px,py,p);

  let steps = Math.floor(size*2);
  for (let i=0;i<steps;i++){
    for (let j=0;j<steps;j++){
      let dx = i-size;
      let dy = j-size;
      if (dx*dx+dy*dy>size*size) continue;

      let sx = dx/size;
      let sy = dy/size;

      let c = cloudNoise(sx,sy,t+p.angle*2);
      if (c>0.3){
        ctx.fillStyle = "rgba(255,255,255,0.12)";
        ctx.fillRect(px+dx,py+dy,1,1);
      }
    }
  }
}

/* ------------------------------------------------------------
   LIGHT DIRECTION FROM HOST STAR
------------------------------------------------------------ */
function lightDirection(star, pos){
  const dx = star.x-pos.x;
  const dy = star.y-pos.y;
  const m = Math.sqrt(dx*dx+dy*dy)+0.0001;
  return {lx:dx/m, ly:dy/m};
}

/* ------------------------------------------------------------
   SHADING (DAY/NIGHT TERMINATOR)
------------------------------------------------------------ */
function drawLighting(px,py,size,p,s){
  const light = lightDirection(s,{x:px,y:py});
  let steps = Math.floor(size*2);

  for (let i=0;i<steps;i++){
    for (let j=0;j<steps;j++){
      let dx=i-size, dy=j-size;
      if (dx*dx+dy*dy>size*size) continue;

      let sx=dx/size, sy=dy/size;
      let L = sx*light.lx + sy*light.ly;

      if (L<0){
        let n = Math.min(1, -L*0.9);
        ctx.fillStyle = `rgba(0,0,0,${n})`;
        ctx.fillRect(px+dx,py+dy,1,1);
      }
    }
  }
}

/* ------------------------------------------------------------
   GAS GIANT RINGS + RING SHADOW
------------------------------------------------------------ */
function drawRing(px,py,size,p,light){
  if (p.type!=="gas giant") return;

  ctx.strokeStyle="rgba(200,200,255,0.3)";
  ctx.lineWidth=1.1;

  ctx.beginPath();
  ctx.ellipse(px,py,size*1.8,size*0.45,Math.atan2(light.ly,light.lx),0,Math.PI*2);
  ctx.stroke();
}

function drawRingShadow(px,py,size,p,s){
  if (p.type!=="gas giant") return;

  const light = lightDirection(s,{x:px,y:py});
  ctx.strokeStyle="rgba(0,0,0,0.22)";
  ctx.lineWidth=1.2;

  ctx.beginPath();
  ctx.ellipse(
    px-light.lx*size*0.5,
    py-light.ly*size*0.5,
    size*1.8,size*0.45,
    Math.atan2(light.ly,light.lx),
    0,Math.PI*2
  );
  ctx.stroke();
}

/* ------------------------------------------------------------
   WEATHER SYSTEM (STORMS + LIGHTNING)
------------------------------------------------------------ */
let weatherTime = 0;
function updateWeather(dt){ weatherTime += dt*timewarp; }

function cycloneField(x,y,t){
  return Math.sin((x*3+t*0.3))*Math.cos((y*3-t*0.3));
}

function lightningFlash(p){
  let chance = 0.0003 + p.temp/200000;
  return Math.random()<chance;
}

function drawWeather(px,py,size,p){
  let steps=Math.floor(size*2);
  for (let i=0;i<steps;i++){
    for (let j=0;j<steps;j++){
      let dx=i-size, dy=j-size;
      if (dx*dx+dy*dy>size*size) continue;

      let sx=dx/size, sy=dy/size;
      let storm=cycloneField(sx,sy,weatherTime+p.angle*3);

      if (storm>0.38){
        ctx.fillStyle="rgba(255,255,255,0.14)";
        ctx.fillRect(px+dx,py+dy,1,1);
      }

      if (lightningFlash(p)){
        ctx.fillStyle="rgba(255,255,200,0.25)";
        ctx.fillRect(px+dx,py+dy,1,1);
      }
    }
  }
}

/* ------------------------------------------------------------
   NIGHT-SIDE CITY LIGHTS (CIVILIZATION)
------------------------------------------------------------ */
function civIntensity(p){
  let life = OmegaAI.predict ? OmegaAI.predict(p.planethost) : 0;
  let tech = p.flux*0.4 + p.temp/10000*0.2;
  let collapse = OmegaCollapse ? OmegaCollapse.evolve(p.planethost) : 0;

  let v = life*0.5 + tech*0.3 + (1-collapse)*0.2;
  return Math.max(0,Math.min(1,v));
}

function drawCityLights(px,py,size,p,s){
  let civ=civIntensity(p);
  if (civ<0.15) return;

  const light=lightDirection(s,{x:px,y:py});
  let steps=Math.floor(size*2);

  for (let i=0;i<steps;i++){
    for (let j=0;j<steps;j++){
      let dx=i-size, dy=j-size;
      if (dx*dx+dy*dy>size*size) continue;

      let sx=dx/size, sy=dy/size;
      let L=sx*light.lx + sy*light.ly;

      if (L>-0.15) continue; // night-side only

      let city = Math.sin(sx*45+sy*52)+Math.cos(sx*55-sy*40);
      if (city>0.4){
        ctx.fillStyle=`rgba(255,220,120,${civ*0.35})`;
        ctx.fillRect(px+dx,py+dy,1,1);
      }
    }
  }
}

/* ------------------------------------------------------------
   DRAW FULL PLANETARY SYSTEM
------------------------------------------------------------ */
function drawStarSystemPlanets(){
  for (const s of stars){
    for (const p of s.planets){

      let px = s.x + Math.cos(p.angle)*p.dist;
      let py = s.y + Math.sin(p.angle)*p.dist;
      let pz = s.z;

      let Pp = projectPoint(px,py,pz);
      let size = Math.max(1.4, p.radius/(p.dist*0.03 + 0.7));
      let spin = p.angle;

      // full rendering order:
      drawPlanetSurface(Pp.X,Pp.Y,size,p,spin);
      drawAtmosphere(Pp.X,Pp.Y,size,p,performance.now()/800);
      drawLighting(Pp.X,Pp.Y,size,p,s);

      const light = lightDirection(s,{x:Pp.X,y:Pp.Y});
      drawRingShadow(Pp.X,Pp.Y,size,p,s);
      drawRing(Pp.X,Pp.Y,size,p,light);

      drawWeather(Pp.X,Pp.Y,size,p);
      drawCityLights(Pp.X,Pp.Y,size,p,s);
    }
  }
}
